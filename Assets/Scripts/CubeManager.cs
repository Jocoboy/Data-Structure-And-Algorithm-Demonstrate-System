using System;
using System.Collections.Generic;
using System.ComponentModel;
using TMPro;
using UnityEngine;

/// <summary>
/// This class is used to manage cubes generated by Dijstra Algoritm.
/// <summary>

public class CubeManager : MonoBehaviour
{

    /**
    Input:      Output:
    6 9         Length of shortest path: 17
    1 2 1
    1 3 12
    2 3 9
    2 4 3
    3 5 5
    4 3 4
    4 5 13
    4 6 15
    5 6 4
    */
    private const float SPACE = 5f;
    private int vertexNum;
    private SingleGraph graph;
    private double[,] matrix;
    public enum ResoucesPaths
    {
        [Description("Prefabs/Cube")]
        CUBE,
        [Description("Prefabs/Sphere")]
        SPHERE,
        [Description("Prefabs/Numbers/")]
        NUMBERS,
        [Description("Prefabs/Item")]
        PATH_ITEM
    }
    public GameObject cubePrefab;
    public GameObject spherePrefab;
    public GameObject pathItemPrefab;
    public List<GameObject> cubeList;
    public List<GameObject> numberList;
    public List<Tuple<int, int,double>> redCubeV2List;

    public Transform viewTf;
    private void Awake()
    {
        cubePrefab = Resources.Load(MyTool.GetEnumDescription(ResoucesPaths.CUBE)) as GameObject;
        spherePrefab = Resources.Load(MyTool.GetEnumDescription(ResoucesPaths.SPHERE)) as GameObject;
        pathItemPrefab = Resources.Load(MyTool.GetEnumDescription(ResoucesPaths.PATH_ITEM)) as GameObject;

        viewTf = GameObject.Find("Canvas(Main Camera)/Scroll View/Viewport/Content").GetComponent<Transform>();

        cubeList = new List<GameObject>();
        numberList = new List<GameObject>();
        redCubeV2List = new List<Tuple<int, int,double>>();
        for (int i = 0; i <= 9; i++)
        {
            GameObject numGo = Resources.Load(MyTool.GetEnumDescription(ResoucesPaths.NUMBERS) + "n" + i) as GameObject;
            numberList.Add(numGo);
        }
        vertexNum = Utilities.VertexNum;
        //print("@"+vertexNum);
        graph = Utilities.graph;
        matrix = Utilities.newDijkstra.Matrix;
        /******************test module***********************
                vertexNum = 6;
                matrix = new float[7, 7];
                for (int i = 0; i < 7; i++)
                {
                    for (int j = 0; j < 7; j++)
                    {
                        matrix[i, j] = float.PositiveInfinity;
                    }
                }
                matrix[1, 2] = 1;
                matrix[1, 3] = 12;
                matrix[2, 3] = 9;
                matrix[2, 4] = 3;
                matrix[3, 5] = 5;
                matrix[4, 3] = 4;
                matrix[4, 5] = 13;
                matrix[4, 6] = 15;
                matrix[5, 6] = 4;
        **************************************************/
        GameObject pathItem = GameObject.Instantiate(pathItemPrefab);
        //pathItem.GetComponent<RectTransform>().rotation = Quaternion.identity;
        pathItem.transform.SetParent(viewTf);
        pathItem.GetComponent<RectTransform>().anchoredPosition3D = new Vector3(0, 0, 0);
        pathItem.name = "from-to-weight";
        for (int i = 1; i <= vertexNum; i++)
        {
            for (int j = 1; j <= vertexNum; j++)
            {
                if (matrix[i, j] != float.PositiveInfinity)
                {
                    redCubeV2List.Add(new Tuple<int, int, double>(i, j, matrix[i, j]));
                    pathItem = GameObject.Instantiate(pathItemPrefab);
                    //pathItem.GetComponent<RectTransform>().rotation = Quaternion.Euler(0.0f, 0.0f, 0.0f)
                    pathItem.transform.SetParent(viewTf);
                    pathItem.GetComponent<RectTransform>().anchoredPosition3D = new Vector3(0, 0, 0);
                    TextMeshProUGUI[] items = pathItem.GetComponentsInChildren<TextMeshProUGUI>(); 
                    items[0].text = i.ToString();
                    items[1].text = j.ToString();
                    items[2].text = matrix[i, j].ToString();
                   
                    pathItem.name = ""+i +"-"+ j+"-"+matrix[i,j];
                }
            }
        }
    }

    private void Start()
    {
        for (int i = 1; i <= vertexNum; i++)
        {
            for (int j = 1; j <= vertexNum; j++)
            {
                Vector3 location = new Vector3((i - vertexNum / 2) * SPACE, 1, (j - vertexNum / 2) * SPACE);
                GameObject go = GameObject.Instantiate(cubePrefab, location, Quaternion.identity);
                go.name = "Cube[" + i + "," + j + "]";
                if (matrix[i, j] != float.PositiveInfinity)
                {
                    go.GetComponent<Renderer>().material.color = Color.red;
                }
                cubeList.Add(go);
            }
        }

        for (int i = 1; i <= vertexNum; i++)
        {
            GameObject origin = GameObject.Instantiate(spherePrefab, new Vector3((i - vertexNum / 2) * SPACE, 2, (i - vertexNum / 2) * SPACE), Quaternion.identity);
            origin.name = "sphere[" + i + "," + i + "]";
            GameObject cube = cubeList[(i - 1) * (vertexNum + 1)];
            cube.GetComponent<Renderer>().material.color = Color.black;
            cube.AddComponent(System.Type.GetType("Cube"));
            GameObject numGo = GameObject.Instantiate(numberList[i], Vector3.zero, Quaternion.identity);
            numGo.AddComponent<BoxCollider>();
            numGo.transform.parent = cube.transform;
            numGo.transform.localPosition = new Vector3(0, 2, 0);
        }

        foreach (var v2 in redCubeV2List)
        {
            int cube_i = v2.Item2;
            int cube_j = v2.Item1; // because the pos of center cube and reference cube are contrarily
            int unit = vertexNum;
            int cube_index = (cube_i - 1) * unit + cube_j - 1;
            Vector3 centerCubeV3 = cubeList[cube_index].transform.position;
            float radius = SPACE*Mathf.Abs(cube_i-cube_j);
            int start = 9; // start point of first cube
            int end = 18; // end point of last cube
            if(cube_i < cube_j)
            {
                start = -9;
                end = start + 9;
            }
            int k = 10;
            int density = k*Mathf.Abs(cube_i - cube_j); // desity of cube(The larger,the smoother)
            Color pathColor = new Color((cube_i + 255) % 255, (cube_j + 255) % 255, ((cube_i - cube_j) + 255) % 255);
            for (int i = start * density; i < end * density; i++) // generate cube anticlockwise
            {
                GameObject cube = (GameObject)GameObject.Instantiate(cubePrefab);
                float angle = i * 10/density;
                float radian = (angle / 180) * Mathf.PI;
                float x = centerCubeV3.x + radius * Mathf.Cos(radian);
                float z = centerCubeV3.z + radius * Mathf.Sin(radian);
                cube.transform.position = new Vector3(x, centerCubeV3.y, z);
                cube.transform.localScale = new Vector3(5.0f/k, 5.0f/k ,5.0f/k);
                cube.transform.LookAt(centerCubeV3);
                cube.GetComponent<Renderer>().material.color = /*pathColor*/Color.white;
            }
        }

    }


}
